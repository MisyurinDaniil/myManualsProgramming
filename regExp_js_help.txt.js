// РЕГУЛЯРНЫЕ ВЫРАЖЕНИЯ JS

// Syntax 1
let regExp = new RegExp('выражение', 'флаги');
// Syntax 2
let regExp = /выражение/флаги
let str = 'Язык JavaScript называется так из-за популярности языка Java';
let regExp = new RegExp('java', 'i');
console.log(regExp);

// String methods
// search
// -1 - вхождений не найдено
// Возвращает индекс первого вхождения
console.log(str.search(regExp)); // -1?

// match
// возвращает массив-бъект с подробной информацией если совпадение одно
// если ничего не найдено то вернет null
console.log(str.match(/java/ig));

// replace (замена)
console.log('+7 (000)000-00-00'.replace('-', ':'));
console.log('+7 (000)000-00-00'.replace(/-/g, ':'));

alert( "We will, we will".replace(/we/i, "I") ); // I will, we will
alert( "We will, we will".replace(/we/ig, "I") ); // I will, I will

let name = 'Snow, John';
console.log(name.replace(/([a-z]+), ([a-z]+)/i, '$2 $1'));
console.log(name.replace(/([a-z]+), ([a-z]+)/i, '$&'));

// Метод regexp.test(str) проверяет, есть ли хоть одно совпадение, если да, 
// то возвращает true, иначе false.
console.log(/java/i.test(str));

// exec
let result;
let regExp = /java/ig;

console.log(`Начальный lastIndex ${regExp.lastIndex}`);
while (result = regExp.exec(str)) {
  console.log(result);
  console.log(`Текущий lastIndex ${regExp.lastIndex}`);
}
console.log(`Конечный lastIndex ${regExp.lastIndex}`);

Флаги
i - поиск без учета регистра. С этим флагом поиск не зависит от регистра: нет разницы между A и a
g - множественный поиск. С этим флагом поиск ищет все совпадения, без него – только первое.
m - многострочный поиск. Он влияет только на поведение ^ и $.
    В многострочном режиме они означают не только начало/конец текста, но и начало/конец каждой строки в тексте.
s - Включает режим «dotall», при котором точка . может соответствовать символу перевода строки \n 

Классы
\d - [0123456789] - [0-9] - («d» от английского «digit» означает «цифра»). Цифра: символ от 0 до 9.
\D - [^0123456789] - [^0-9] - Не цифра: любой символ, кроме \d, например буква.
\w - [a-z0-9_] - («w»: от английского «word» – «слово»). Символ «слова», а точнее – буква латинского алфавита 
     или цифра или подчёркивание _. Нелатинские буквы не являются частью класса \w, то есть буква 
     русского алфавита не подходит.
\W - Любой символ, кроме \w, то есть не буквы из латиницы, не знак подчёркивания и не цифра. 
     В частности, русские буквы принадлежат этому классу.
\s - («s»: от английского «space» – «пробел»). Пробельные символы: включает в себя символ пробела, табуляции \t, 
     перевода строки \n и некоторые другие редкие пробельные символы, обозначаемые как \v, \f и \r.
\S - Не пробел: любой символ, кроме \s, например буква.
\b - граница слова
\B - не граница слова
Для примера, \d\s\w обозначает «цифру», за которой идёт пробельный символ, а затем символ слова, например 1 a
    let str = "Есть ли стандарт CSS4?";
    let regexp = /CSS\d/
    alert( str.match(regexp) ); // CSS4
    alert( "I love HTML5!".match(/\s\w\w\w\w\d/) ); // ' HTML5'
    console.log('Язык JavaScript это не Java вам =)'.match(/\bjava\b/ig)); // Java

Точка 
. – это специальный символьный класс, который соответствует «любому символу, кроме новой строки
    let regexp = /CS.4/;
    alert( "CSS4".match(regexp) ); // CSS4
    alert( "CS-4".match(regexp) ); // CS-4
    alert( "CS 4".match(regexp) ); // CS 4 (пробел тоже является символом)

Якоря
^ - начало строки
$ - конец строки
    let str1 = "Mary had a little lamb";
    alert( /^Mary/.test(str1) ); // true
    let str1 = "it's fleece was white as snow";
    alert( /snow$/.test(str1) ); // true

Наборы и диапазоны
Несколько символов или символьных классов в квадратных скобках […] означают «искать любой символ из заданных».
[eao] означает любой из 3-х символов: 'a', 'e' или 'o'.
Ещё квадратные скобки могут содержать диапазоны символов.
[a-z] соответствует символу в диапазоне от a до z, или [0-5] – цифра от 0 до 5
Здесь в [0-9A-F] сразу два диапазона: ищется символ, который либо цифра от 0 до 9, либо буква от A до F.
Если мы хотим найти буквы и в верхнем и в нижнем регистре, то мы можем добавить ещё диапазон a-f: [0-9A-Fa-f].
\d – то же самое, что и [0-9],
\w – то же самое, что и [a-zA-Z0-9_],
\s – то же самое, что и [\t\n\v\f\r ], плюс несколько редких пробельных символов Юникода.
// найти [т или х], после которых идёт "оп"
    alert( "Топ хоп".match(/[тх]оп/gi) ); // "топ", "хоп"
    let regexp = /\d\d[-:]\d\d/g;
    alert( "Завтрак в 09:00. Ужин в 21-30".match(regexp) ); // 09:00, 21-3

Исключающие диапазоны
Помимо обычных диапазонов, есть «исключающие» диапазоны, которые выглядят как [^…].
[^aeyo] – любой символ, за исключением 'a', 'e', 'y' или 'o'.
[^0-9] – любой символ, за исключением цифры, то же, что и \D.
[^\s] – любой непробельный символ, то же, что и \S.
    alert( "alice15@gmail.com".match(/[^\d\sA-Z]/gi) ); // @ и 

Квантификаторы
{m} - строго m раз
{m,n} - от m до n раз
{m,} - от m до бесконечности
{,n} - от 0 до n раз
сокращения
+ - {1,}
* - {0,}
? - {0,1}
    console.log('+7-(000) 000:00-00'.match(/\d+/g).join('')); // 70000000000
    console.log('color colour'.match(/colou?r/g));
    console.log('color colour colotr'.match(/colo[ut]?r/g));

https://learn.javascript.ru/regexp-greedy-and-lazy - лучшая статья про жадный и ленивый режимы
Все квантификаторы по умолчанию работают в жадном режиме.
В жадном режиме (по умолчанию) квантификатор повторяется столько раз, сколько это возможно.
Движок регулярного выражения пытается получить максимальное количество символов, соответствующих .+, 
а затем сокращает это количество символ за символом (движется назад), если остаток шаблона не совпадает.
Жадный
    let regexp = /".+"/g;
    let str = 'a "witch" and her "broom" is one';
    alert( str.match(regexp) ); // "witch" and her "broom"
Ленивый
    let regexp = /".+?"/g;
    let str = 'a "witch" and her "broom" is one';
    alert( str.match(regexp) ); // witch, broom

Экранирование
    console.log('Chapter 7.2'.match(/\d\.\d/g));
    console.log('Chapter 7F2'.match(/\d\.\d/g));

Скобочные группы
    alert( 'Gogogo now!'.match(/(go)+/i) ); // "Gogogo"
    let regexp = /(\w+\.)+\w+/g;
    alert( "site.com my.site.com".match(regexp) ); // site.com,my.site.com
    let regexp = /[-.\w]+@([\w-]+\.)+[\w-]+/g;
    alert("my@mail.com @ his@site.com.uk".match(regexp)); // my@mail.com, his@site.com.uk

Именованные группы
    let dateRegexp = /(?<year>[0-9]{4})-(?<month>[0-9]{2})-(?<day>[0-9]{2})/;
    let str = "2019-04-30";
    let groups = str.match(dateRegexp).groups;
    alert(groups.year); // 2019
    alert(groups.month); // 04
    alert(groups.day); // 30

Обратная ссылка по номеру: \N
    let str = `He said: "She's the one!".`;
    let regexp = /(['"])(.*?)\1/g;
    alert( str.match(regexp) ); // "She's the one!"
Движок регулярных выражений находит первую кавычку из шаблона (['"]) и запоминает её содержимое. 
Это первая скобочная группа.Далее в шаблоне \1 означает «найти то же самое, что в первой скобочной группе», 
а именно – аналогичную кавычку в нашем случае.
Аналогично, \2 означает содержимое второй скобочной группы, \3 – третьей, и так далее.

Обратная ссылка по имени: \k<имя>
    let str = `He said: "She's the one!".`;
    let regexp = /(?<quote>['"])(.*?)\k<quote>/g;
    alert( str.match(regexp) ); // "She's the one!"

Альтернация (или) |
Альтернация – термин в регулярных выражениях, которому в русском языке соответствует слово «ИЛИ».
В регулярных выражениях она обозначается символом вертикальной черты |.
    let regexp = /html|css|java(script)?/gi;
    let str = "Сначала появился язык Java, затем HTML, потом JavaScript";
    alert( str.match(regexp) ); // Java,HTML,JavaScript
    let regexp = /([01]\d|2[0-3]):[0-5]\d/g;
    alert("00:00 10:10 23:59 25:99 1:2".match(regexp)); // 00:00,10:10,23:59

Опережающая (lookahead) и ретроспективная (lookbehind) проверка.
Синтаксис опережающей проверки: X(?=Y).
Он означает: найди X при условии, что за ним следует Y. Вместо X и Y здесь может быть любой шаблон.
Обратим внимание, что проверка – это именно проверка, содержимое скобок (?=...) не включается в результат
    let str = "1 индейка стоит 30€";
    alert( str.match(/\d+(?=€)/) ); // 30, число 1 проигнорировано, так как за ним НЕ следует €
Возможны и более сложные проверки, например X(?=Y)(?=Z) означает:
    Найти X.
    Проверить, идёт ли Y сразу после X (если нет – не подходит).
    Проверить, идёт ли Z сразу после X (если нет – не подходит).
    Если обе проверки прошли – совпадение найдено.

Негативная опережающая проверка
Синтаксис: X(?!Y)
Он означает: найди такой X, за которым НЕ следует Y.
    let str = "2 индейки стоят 60€";
    alert( str.match(/\d+(?!€)/) ); // 2 (в этот раз проигнорирована цена)

Ретроспективная проверка
Ретроспективная проверка выполняет такую же функцию, но с просмотром назад. Другими словами, 
она находит соответствие шаблону, только если перед ним есть что-то заранее определённое.
Синтаксис:
    Позитивная ретроспективная проверка: (?<=Y)X, ищет совпадение с X при условии, что перед ним ЕСТЬ Y.
    Негативная ретроспективная проверка: (?<!Y)X, ищет совпадение с X при условии, что перед ним НЕТ Y.
    let str = "1 индейка стоит $30";
    // знак доллара экранируем \$, так как это специальный символ
    alert( str.match(/(?<=\$)\d+/) ); // 30, одинокое число игнорируется
Если нам необходимо найти количество индеек – число, перед которым не идёт $, мы можем использовать негативную ретроспективную проверку (?<!\$)\d+:
    let str = "2 индейки стоят $60"; 
    alert( str.match(/(?<!\$)\d+/) ); // 2 (проигнорировалась цена)

Скобочные группы
Например, в шаблоне \d+(?=€) знак € не будет включён в результат. Это логично, 
ведь мы ищем число \d+, а (?=€) – это всего лишь проверка, что за ним идёт знак €.
Но в некоторых ситуациях нам может быть интересно захватить и то, что в проверке. 
Для этого нужно обернуть это в дополнительные скобки.
    let str = "1 индейка стоит 30€";
    let regexp = /\d+(?=(€))/; // добавлены дополнительные скобки вокруг €|kr
    alert( str.match(regexp) ); // 30, €